#!/usr/bin/env pandda.python

import os, sys, copy, glob
import shutil
import pandas
import libtbx.phil

#################################
import matplotlib
matplotlib.use('Agg')
matplotlib.interactive(0)
from matplotlib import pyplot
pyplot.style.use('ggplot')
##################################

from bamboo.common.command import CommandManager

blank_arg_prepend = {None:'dir=', '.pdb':'pdb=', '.mtz':'mtz='}

master_phil = libtbx.phil.parse("""
input {
    dir = None
        .type = path
        .multiple = True
    pdb_style = "*.dimple.pdb"
        .type = str
        .multiple = False
    mtz_style = "*.dimple.mtz"
      .type = str
        .multiple = False
}
output {
    log = "ringer.log"
        .type = str
        .multiple = False
}
settings {
    # XXX mmtbx.ringer can only take this an integer, >1 XXX#
    angle_sampling = 2
        .type = int
        .multiple = False
}
""")

############################################################################################
#                                   FUNCTIONS                                              #
############################################################################################

def process_with_ringer(pdb, mtz, angle_sampling, output_dir=None, output_base=None):
    """Analyse a pdb-mtz pair with mmtbx.ringer"""    
    
    assert os.path.exists(pdb), 'PDB File does not exist'
    assert os.path.exists(mtz), 'MTZ File does not exist'

    if not output_dir:  output_dir = os.path.dirname(pdb)
    if not output_base: output_base = os.path.splitext(os.path.basename(pdb))[0]

    # Check/create output directory
    if not os.path.exists(output_dir): os.mkdir(output_dir)

    output_csv = os.path.join(output_dir, output_base+'.csv')
    # Import pandas for utilising dataframes
    import pandas
    ###################################################
    #Run Ringer
    ###################################################

    # Only run if results don't already exist
    if not os.path.exists(output_csv):
        # Initialise and populate command object
        ringer = CommandManager(program='/usr/local/phenix/phenix-1.9-1682/build/intel-linux-2.6-x86_64/bin/mmtbx.ringer')
        ringer.add_command_line_arguments(pdb, mtz)
        ringer.add_command_line_arguments('sampling_angle={}'.format(angle_sampling))
        ringer.add_command_line_arguments('output_base={}'.format(os.path.join(output_dir, output_base)))
        # Print and run
        ringer.print_settings()
        ringer.run()
        # Write log
        ringer.write_output(os.path.join(output_dir, output_base+'.log'))

    # Check the output csv file exists
    output_csv = os.path.join(output_dir, output_base+'.csv')
    assert os.path.exists(output_csv), 'Ringer output CSV does not exist: {}'.format(output_csv)

    return output_csv

def normalise_and_sort_ringer_results(current_dataset_results,params):
    #Extract from current residue in dataset
    residue = current_dataset_results.index[0]
    start_ang  = current_dataset_results.values[0,2]
    ang_rel = params.settings.angle_sampling*current_dataset_results.columns.values[3:]-3
    map_values = current_dataset_results.values[0,3:]

    print 'Showing data for {}'.format(residue)
    # Set angles
    ang = (start_ang+ang_rel)%360
   
    ###################################################
    # Sort Angles
    ##################################################
    sorted_idx = sorted(range(len(ang)), key=lambda i: ang[i])
    sorted_angles = [ang[i] for i in sorted_idx]
    sorted_map_values = [map_values[i] for i in sorted_idx]
    
    return (sorted_angles,sorted_map_values)

def line_plot_ringer(sorted_angles,sorted_map_values,title,filename,out_dir):

    fig=pyplot.figure()
    pyplot.plot(sorted_angles, sorted_map_values)
    pyplot.title(title)
    pyplot.xlabel('Angle')
    pyplot.tight_layout()
    pyplot.savefig(os.path.join(out_dir,filename))
    pyplot.close(fig)

def multiple_line_plot_ringer(all_data_list,title, filename, out_dir):

    fig=pyplot.figure()
    pyplot.title(title)
    
    for i in range(0,len(all_data_list)):
        sorted_angles=all_data_list[i][0]
        sorted_map_values=all_data_list[i][1]
        pyplot.plot(sorted_angles,sorted_map_values)
    
    pyplot.xlabel('Angle')
    pyplot.tight_layout()
    pyplot.savefig(os.path.join(out_dir,filename))
    pyplot.close(fig)

def linear_interpolate_ringer_results(sorted_angles,sorted_map_values,angle_sampling):
    # Import numpy for interpolation routines
    import numpy

    # Extend the map values, and angles to include the first element at end 
    # (over 360 deg),and the last elment at the start (below 0 deg)
    sorted_map_values.insert(0,sorted_map_values[-1])
    # now need to append 2nd value to end of list, as 1st values is the appended value
    sorted_map_values.append(sorted_map_values[1])
    sorted_angles.insert(0,sorted_angles[0]-angle_sampling)
    sorted_angles.append(sorted_angles[-1]+angle_sampling)  

    # Generate a set of angles to interpolate to based on the angle sampling
    interpolated_angles = numpy.arange(1, 360, angle_sampling)
    
    # interpolate
    interpolated_map_values = numpy.interp(interpolated_angles,sorted_angles,sorted_map_values) 

    return (interpolated_angles,interpolated_map_values)

def correlation_single_residue(input_csv,residue,output_dir):
    # Import numpy for correlation routines, pandas for dataframes
    import numpy, pandas
    
    data = pandas.read_csv(input_csv)
    # Allocate array to store map values across datasets. Removing one from 
    # number of columns due to dataset name stored with map values
    all_map_values=numpy.zeros((len(data.values),len(data.columns)-1))
    dataset_labels=[]
    
    # Extract map values and dataset labels from Pandas import of CSV 
    for i in range(0,len(data.values)):
        dataset_labels.append(data.values[i,0])
        map_values = data.values[i,1:]  
        all_map_values[i]=map_values
    # Generate correlation coefficents
    correlation_matrix = numpy.corrcoef(all_map_values)
    # Store in labelled data frame
    correlation_data = pandas.DataFrame(correlation_matrix, index = dataset_labels, columns = dataset_labels)
    # Correlation data as CSV 
    filename='{}-from {} datasets-correlation-ringer.csv'.format(residue,len(data.values)) 
    correlation_csv = correlation_data.to_csv(os.path.join(output_dir,filename))

    return correlation_csv

    #from IPython import embed; embed() 

def run(params):

    # Dictionary to store all of the 
    # ringer results for each of the 
    # datasets
    all_results = {}

    for dir in params.input.dir:
        # Label the dataset by the directory name
        label = os.path.basename(dir)
        pdb = glob.glob(os.path.join(dir, params.input.pdb_style))
        mtz = glob.glob(os.path.join(dir, params.input.mtz_style))
        assert pdb, 'No PDB Files found in {} matching {}'.format(dir, params.input.pdb_style)
        assert mtz, 'No MTZ Files found in {} matching {}'.format(dir, params.input.mtz_style)
        pdb = pdb[0]
        mtz = mtz[0]

        # Process dataset with ringer and convert results to DataFrame
        ringer_csv = process_with_ringer(pdb=pdb, mtz=mtz,angle_sampling=params.settings.angle_sampling, output_dir=dir)
        ringer_results = pandas.DataFrame.from_csv(ringer_csv, header=None)
        all_results[label] = ringer_results
        
    # Pull out the "first" ringer results set as a reference
    ref_set = all_results.values()[0]

    # Map and angle types currently selected to analyse
    map_type = '2mFo-DFc'
    angle_type = 'chi1'
    out_dir = 'Processed_data'  

    # Create an output directory if it doesn't already exist 
    out_dir = 'Processed_data'
    if not os.path.isdir(out_dir):
        os.makedirs(out_dir)

    # Iterate through the residues
    for residue, data in ref_set.iterrows():
        residue_data_list = []

        interpolate_csv = '{}_{}_Datasets_{}_{}-ringer.csv'.format(residue,len(params.input.dir),map_type,angle_type)
    
        if not os.path.exists(os.path.join(out_dir,interpolate_csv)):
        
            # Iterate through the datasets
            for dataset_label, dataset_results in all_results.iteritems():
                # Choose a map_type/angle_type
                dataset_results = dataset_results.loc[(dataset_results[1] == map_type)]
                dataset_results = dataset_results.loc[(dataset_results[2] == angle_type)]
                 
                current_dataset_results = dataset_results.loc[(dataset_results.index == residue)]    

                sorted_angles, sorted_map_values = normalise_and_sort_ringer_results(current_dataset_results, params=params)
                line_plot_ringer(sorted_angles, sorted_map_values, title=residue, filename='{}-{}.png'.format(residue, dataset_label),out_dir=out_dir)

                interpolated_angles,interpolated_map_values = linear_interpolate_ringer_results(sorted_angles,sorted_map_values,angle_sampling=params.settings.angle_sampling)          
                
                # Store these in a list
                residue_data_list.append((interpolated_angles, interpolated_map_values))
                
                # If it doesn't exist: Create dataframe to store results from one residue, across multiple datasets 
                if not 'single_residue_multiple_datasets' in locals():
                    single_residue_multiple_datasets = pandas.DataFrame(columns=interpolated_angles)

                # Populate dataframe with results from one residue, across multiple datasets 
                single_residue_multiple_datasets.loc['{}'.format(dataset_label)]=interpolated_map_values        

            # Print results for all of the datasets for this residue in the same graph
            # Output CSV from one resiude, multiple datasets
            multiple_line_plot_ringer(residue_data_list,title=residue, filename='all-{}-{}-dataset.png'.format(residue, len(residue_data_list)),out_dir=out_dir)  
            pandas.DataFrame.to_csv(single_residue_multiple_datasets,os.path.join(out_dir,interpolate_csv))
        else:
            print '{}:Interpolated CSVs already generated, for these {} datasets'.format(residue,len(params.input.dir))

    # Calculate correlation coefficents     
    for residue, data in ref_set.iterrows():

        interpolate_csv = '{}_{}_Datasets_{}_{}-ringer.csv'.format(residue,len(params.input.dir),map_type,angle_type)
        input_csv = os.path.join(out_dir,interpolate_csv)
        
        correlation_csv='{}-from {} datasets-correlation-ringer.csv'.format(residue,len(params.input.dir))

        if not os.path.exists(os.path.join(out_dir,correlation_csv)):
            correlation_csv = correlation_single_residue(input_csv,residue,out_dir)
        else:
            print'{}: Correlation CSV already generated, for these {} datasets'.format(residue,len(params.input.dir))


# For allowing command manager 
if __name__ == '__main__':
    from giant.jiffies import run_default
    run_default(run=run, master_phil=master_phil, args=sys.argv[1:], blank_arg_prepend=blank_arg_prepend)
